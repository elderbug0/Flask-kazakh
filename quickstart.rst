Жылдам іске кіру
==========

Жұмысқа кірісуді күте алмайсыз ба? Бұл бет Flask туралы жақсы түсінік береді.
Жобаны орнату және алдымен Flask орнату үшін :doc: `installation` тармағын орындаңыз.


Минималды қолдану
---------------------

Минималды Flask қосымшасы келесідей көрінеді:

.. code-block:: python

    from flask import Flask

    app = Flask(__name__)

    @app.route("/")
    def hello_world():
        return "<p>Hello, World!</p>"

Сонымен, Бұл код не істеді?

1. Алдымен біз импорттадық: :class:`~flask.Flask` классты. Бұл класстың данасы біздің wsgi қосымшасы болады.
2. Әрі қарай, біз осы класстың данасын жасаймыз. Бірінші аргумент-модульдің немесе қолданба бумасының атауы. ``__name__`` - бұл көптеген жағдайларға сәйкес келетін ыңғайлы төте жол. Бұл Flask шаблондар мен статикалық файлдар сияқты ресурстарды қайдан іздеу керектігін білуі үшін қажет.
3. Содан кейін біз  :meth:`~flask.Flask.route`  деген декоратор қолданамыз. Бұл Flask-ке біздің функцияны қандай URL іске қосуы керектігін айтады.
4. Функция пайдаланушының шолғышында көрсеткіміз келетін хабарды қайтарады. Әдепкі мазмұн түрі-HTML, сондықтан жолдағы HTML браузерде көрсетіледі.

Оны :file:`hello.py` - немесе ұқсас атаулармен сақтаңыз. Қолданбаны :file:`flask.py` - атымен сақтамауын назар аударыңыз, өйткені бұл Flask-тің өзіне атаулар қақтығысы боп келеді.

Қолданбаны іске қосу үшін ``flask``пәрменін немесе ``python -m flask`` қолданыңыз.
``--app`` опциясын пайдаланып, flask-ке қолданбаңыздың қай жерде екенін айту керек.

.. code-block:: text

    $ flask --app hello run
     * Serving Flask app 'hello'
     * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)

.. admonition:: Қолданбаны анықтау әрекеті

    Егер файл ``app.py`` немесе ``wsgi.py``  аталған болса,  сізге ``--app`` қолданудың қажеті жоқ. 
    Қосымша ақпарат алу үшін :doc:`/cli` қараңыз.

Бұл өте қарапайым кіріктірілген серверді іске қосады, ол тестілеуге жеткілікті, бірақ сіз өндірісте қолданғыңыз келмейтін шығар. Орналастыру параметрлері келесі бөлімде берілген :doc:`deploying/index`.

Енді http://127.0.0.1:5000 / адреске барып сіз hello world сәлемдесуін көруіңіз керек.

Егер басқа бағдарлама 5000 портын қолданып жатса, сіз серверді іске қосқан кезде ``OSError: [WinError 10013]`` немесе ``OSError: [Errno 98]`` көресіз. :ref:`address-already-in-use` көріп, онымен қалай күресуге болады.

.. _public-server:

.. admonition:: Сырттан көрінетін Сервер

  Егер сіз серверді іске қоссаңыз, серверге желідегі кез келген басқа компьютерден емес, тек өз компьютеріңізден кіруге болатынын байқайсыз.  Бұл әдепкі болып табылады, өйткені күйін келтіру режимінде қолданба пайдаланушысы компьютерде ерікті Python кодын орындай алады.

   Егер сізде отладчик өшірілген болса немесе желі пайдаланушыларына сенсеңіз, пәрмен жолына  ``--host=0.0.0.0`` қосу арқылы серверді жалпыға қол жетімді ете аласыз::

       $ flask run --host=0.0.0.0

  Бұл сіздің операциялық жүйеңізге барлық жалпыға ортақ IP мекенжайларын тыңдауды көрсетеді.

Жөндеу режимі
----------

 ``flask run``  командасы әзірлеу серверін іске қосудан гөрі көп нәрсе істей алады. Күйін келтіру режимін қосу арқылы код өзгерген кезде сервер автоматты түрде қайта жүктеледі және сұрау кезінде қате пайда болса, шолғышта интерактивті күйін келтірушіні көрсетеді.

.. image:: _static/debugger.png
    :align: center
    :class: screenshot
    :alt: The interactive debugger in action.

.. warning::

   Отладчик браузерден Python - да ерікті кодты орындауға мүмкіндік береді. Ол pin кодымен қорғалған, бірақ бәрібір қауіпсіздікке үлкен қауіп төндіреді. Өндірістік ортада әзірлеу серверін немесе отладчикті іске қоспаңыз.

Жөндеу режимін қосу үшін ``--debug`` опциясын пайдаланыңыз.

.. code-block:: text

    $ flask --app hello run --debug
     * Serving Flask app 'hello'
     * Debug mode: on
     * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
     * Restarting with stat
     * Debugger is active!
     * Debugger PIN: nnn-nnn-nnn

Мұны да қараңыз:

-   :doc:`/server` and :doc:`/cli` күйін келтіру режимінде іске қосу туралы ақпарат алу үшін.
-   :doc:`/debugging`  кірістірілген отладчикті және басқа отладчиктерді пайдалану туралы ақпарат алу үшін.
-   :doc:`/logging` and :doc:`/error handling`  қателерді тіркеу және әдемі қате беттерін көрсету үшін.


HTML-ден шығу
-------------

HTML (Flask-те әдепкі жауап түрі) қайтарылған кезде, инъекциялық шабуылдардан қорғау үшін пайдаланушының шығыс деректерінде көрсетілген кез келген мәндері қорғалған болуы керек. Кейінірек ұсынылған Jinja көмегімен көрсетілген HTML шаблондары мұны автоматты түрде жасайды.

Мұнда көрсетілген   :func:`~markupsafe.escape`  қолмен пайдалануға болады.
Көптеген мысалдарда бұл қысқаша қабылданбайды, бірақ сіз әрқашан сенімсіз деректерді қалай пайдаланатыныңызды білуіңіз керек.

.. code-block:: python

    from markupsafe import escape

    @app.route("/<name>")
    def hello(name):
        return f"Hello, {escape(name)}!"

Егер пайдаланушы ``<script>alert("bad")</script>`` атауын жібере алса, экрандау сценарийді пайдаланушының шолғышында іске қосудың орнына оны мәтін ретінде көрсетуге әкеледі.

маршруттағы ``<name>`` URL мекенжайынан мәнді алады және оны қарау функциясына жібереді. Бұл айнымалы ережелер төменде түсіндіріледі.

Маршруттау
-------

Заманауи веб-қосымшалар пайдаланушыларға көмектесу үшін мағыналы URL мекенжайларын пайдаланады. Пайдаланушылар бетті ұнатуы ықтимал және егер олар бетте есте сақтай алатын және бетке тікелей кіру үшін пайдалана алатын мағыналы URL мекенжайын пайдаланса, олар қайтып оралады.

функцияны URL мекенжайына байланыстыру үшін :meth:`~flask.Flask.route`  декораторды пайдаланыңыз. ::

@app.route('/')
    def index():
        return 'Index Page'

    @app.route('/hello')
    def hello():
        return 'Hello, World'

Сіз көп нәрсені жасай аласыз! Сіз URL бөліктерін динамикалық етіп жасай аласыз және функцияға бірнеше ережелерді қоса аласыз.

Айнымалы ережелер
``````````````

URL мекенжайына айнымалы бөлімдерді ``<variable_name>`` бөлімдерін белгілеу арқылы қосуға болады. Содан кейін сіздің функцияңыз кілт сөз аргументі ретінде ``<variable_name>``  алады. Қажет болса, дәлел түрін көрсету үшін түрлендіргішті пайдалануға болады, мысалы ``<converter:variable_name>``. ::

    from markupsafe import escape

    @app.route('/user/<username>')
    def show_user_profile(username):
        # сол пайдаланушы үшін пайдаланушы профилін көрсету
        return f'User {escape(username)}'

    @app.route('/post/<int:post_id>')
    def show_post(post_id):
        # берілген идентификатормен хабарламаны көрсету, идентификатор бүтін сан болып табылады
        return f'Post {post_id}'

    @app.route('/path/<path:subpath>')
    def show_subpath(subpath):
        # /path/ кейін ішкі жолды көрсету
        return f'Subpath {escape(subpath)}'

Түрлендіргіштердің түрлері:

========== ==========================================
``string``  (default) кез-келген мәтінді қиғаш сызықсыз қабылдайды
``int``     бүтін оң сандарды қабылдайды
``float``   оң өзгермелі нүкте мәндерін қабылдайды
``float``   ``string`` ұқсас бірақ сонымен бірге қиғаш сызықтарды қабылдайды
``uuid``    UUID жолдарын қабылдайды
========== ==========================================


Бірегей URL мекенжайлары / Қайта бағыттау әрекеті
``````````````````````````````````

Келесі екі ереже соңғы қиғаш сызықты қолданумен ерекшеленеді. ::

    @app.route('/projects/')
    def projects():
        return 'The project page'

    @app.route('/about')
    def about():
        return 'The about page'

``projects`` соңғы нүктесінің канондық URL мекенжайының соңында қиғаш сызық бар. Бұл файлдық жүйедегі қалта сияқты. Егер сіз соңында қиғаш сызығы жоқ URL мекенжайына жүгінсеңіз (``/projects``), Flask сізді соңында қиғаш сызығы бар канондық URL мекенжайына бағыттайды (``/projects``).

 ``about`` соңғы нүктесінің канондық URL мекенжайында соңғы қиғаш сызық жоқ. Бұл файл жолына ұқсас. Соңында қиғаш сызығы бар URL мекенжайына кіру(``/about/``) 404 "Not Found" қатесіне әкеледі. Бұл поискl мекенжайларын осы ресурстарға ғана тән етіп сақтауға көмектеседі, бұл іздеу жүйелеріне бір бетті екі рет индекстеуден аулақ болуға көмектеседі.


.. _url-building:

URL мекенжайын жасау
````````````

Белгілі бір функция үшін URL жасау үшін :func:`~flask.url_for` функциясын қолданыңыз. Ол функцияның атауын өзінің алғашқы аргументі ретінде және әрқайсысы URL ережесінің айнымалы бөлігіне сәйкес келетін кілт сөз аргументтерінің кез келген санын қабылдайды. Айнымалылардың белгісіз бөліктері URL мекенжайына сұрау параметрлері ретінде қосылады.

Неліктен URL мекенжайын  өз үлгілерінде қатаң кодтаудың орнына :func:`~flask.url_for` өзгерту функциясын пайдаланып URL мекенжайларын жасағыңыз келедi?

1. Реверсия көбінесе URL мекенжайларын қатаң кодтауға қарағанда айқынырақ болады.
2. Қатты бағдарламаланған URL мекенжайларын қолмен өзгерту қажеттілігін есте сақтаудың орнына URL мекенжайларын бір уақытта өзгертуге болады.
3. URL мекенжайын құру арнайы таңбаларды қорғауды мөлдір түрде өңдейді.
4. Жасалған жолдар әрқашан абсолютті болып табылады, бұл браузерлердегі салыстырмалы жолдардың күтпеген әрекетін болдырмайды.
5. Егер сіздің қосымшаңыз URL мекен-жайының түбірлік каталогынан тыс орналастырылған болса, мысалы, ``/``/my application`` орнына ``/``,  :func:`~flask.url_for` мұны сіз үшін дұрыс өңдейді.

Мысалы, мұнда біз :meth:`~flask.Flask.test_request_context` әдісін қолданып көреміз :func:`~flask.url_for`. :meth:`~flask.Flask.test_request_context. Flask-ке Python қабығын қолданған кезде де сұрауды өңдейтін сияқты әрекет етуді айтады. Қараңыз :ref:`context-locals`.

.. code-block:: python

    from flask import url_for

    @app.route('/')
    def index():
        return 'index'

    @app.route('/login')
    def login():
        return 'login'

    @app.route('/user/<username>')
    def profile(username):
        return f'{username}\'s profile'

    with app.test_request_context():
        print(url_for('index'))
        print(url_for('login'))
        print(url_for('login', next='/'))
        print(url_for('profile', username='John Doe'))

.. code-block:: text

    /
    /login
    /login?next=/
    /user/John%20Doe


HTTP әдістері
````````````

Веб-қосымшалар URL мекенжайларына кірген кезде әртүрлі HTTP әдістерін қолданады. Flask-пен жұмыс істеу кезінде HTTP әдістерімен танысу керек. Әдепкі бойынша, маршрут тек``GET`` сұрауларына жауап береді. Сіз  әр түрлі HTTP әдістерін өңдеуге арналған маршрут :meth:`~flask.Flask.route` Декоратортын ``methods`` аргументін пайдалана аласыз.
::

    from flask import request

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            return do_the_login()
        else:
            return show_the_login_form()

Жоғарыдағы мысалда маршруттың барлық әдістері бір функцияда сақталады, бұл әрбір бөлік кейбір жалпы деректерді пайдаланса пайдалы болуы мүмкін.

Сондай-ақ, әртүрлі әдістерге арналған көріністерді әртүрлі функцияларға бөлуге болады. Flask келесі маршруттарды жобалау үшін төте жолды ұсынады:  :meth:`~flask.Flask.get` ,   :meth:`~flask.Flask.get` және т. б. әрбір жалпы HTTP әдісі үшін.

.. code-block:: python

    @app.get('/login')
    def login_get():
        return show_the_login_form()

    @app.post('/login')
    def login_post():
        return do_the_login()

Егер ``GET`` болса, Flask автоматты түрде  ``HEAD`` әдісін қолдайды және   `HTTP RFC`_ сәйкес  ``HEAD`` сұрауларын өңдейді. Сол сияқты,  ``OPTIONS`` сіз үшін автоматты түрде жүзеге асырылады.

.. _HTTP RFC: https://www.ietf.org/rfc/rfc2068.txt

Статикалық файлдар
------------

Динамикалық веб-қосымшаларға статикалық файлдар қажет. Әдетте CSS және JavaScript файлдары сол жерден алынады. Ең дұрысы, сіздің веб-серверіңіз сізге қызмет ету үшін конфигурацияланған, бірақ оны әзірлеу кезінде Flask жасай алады. Тек қалтаны жасаңыз :file:`static`пакетте немесе модульдің жанында`static` және ол қолданбадағы ``/static`` мекенжайында қол жетімді болады.

Статикалық файлдар үшін URL мекенжайларын жасау үшін арнайы ``'static'`` соңғы нүкте атауын пайдаланыңыз::

    url_for('static', filename='style.css')

Файл файлдық жүйеде келесідей сақталуы керек: :file:`static/style.css`.

Көрсету үлгілері
-------------------

Python-дан HTML жасау қызық емес және іс жүзінде өте қиын, өйткені қолданбаның қауіпсіздігін қамтамасыз ету үшін HTML-ді өзіңіз қорғауыңыз керек. Сол үшін Flask  -  `Jinja2 <https://pallets projects.com/p/jinja/>` -  шаблон қозғалтқышы автоматты түрде орнатады

Үлгілерді кез келген түрдегі мәтіндік файл жасау үшін пайдалануға болады. Веб-қосымшалар үшін Сіз бірінші кезекте HTML беттерін жасайсыз, бірақ сіз markdown, электрондық пошталарға арналған қарапайым мәтін және басқаларын жасай аласыз.

HTML, CSS және басқа веб-API-ге сілтеме жасау үшін 'MDN Web Docs'_.

.. _MDN Web Docs: https://developer.mozilla.org/

Үлгіні көрсету үшін :func:`~flask.render_template` әдісті қолдануға болады . Сізге тек шаблон атауын және шаблон қозғалтқышына кілт сөз аргументтері ретінде бергіңіз келетін айнымалыларды көрсету керек. Міне, үлгіні қалай салу керектігінің қарапайым мысалы::

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
        return render_template('hello.html', name=name)

Flask үлгілерді :file:`templates ' қалтасынан іздейді. Сонымен, егер сіздің қосымшаңыз модуль болса, онда бұл қалта сол модульдің қасында, егер ол пакет болса, онда ол сіздің пакетіңіздің ішінде болады:

**Кейс 1**: a module::

    /application.py
    /templates
        /hello.html

**Кейс 2**: a package::

    /application
        /__init__.py
        /templates
            /hello.html

Шаблондар жасау үшін Сіз Jinja2 шаблондарының барлық күшін пайдалана аласыз. Jinja2 үлгісі бойынша ресми құжаттаманы <https://jinja.palletsprojects.com/templates / > ' _  қосымша ақпарат алу үшін.

Міне мысал үлгісі:

.. sourcecode:: html+jinja

    <!doctype html>
    <title>Hello from Flask</title>
    {% if name %}
      <h1>Hello {{ name }}!</h1>
    {% else %}
      <h1>Hello, World!</h1>
    {% endif %}

Үлгілердің ішінде сізге :data:`~flask.Flask.config`, :class:`~flask.request`, :class:`~flask.session` және :class:`~flask.g` [#]_ қол жетімді нысандар , сондай-ақ пен мүмкіндіктер:  :func:`~flask.url_for` және :func:`~flask.get_flashed_messages`

Үлгілер, егер мұрагерлік қолданылса, әсіресе пайдалы. Егер сіз оның қалай жұмыс істейтінін білгіңіз келсе, қараңыз :doc:`patterns/template inheritance`. Негізінде, шаблондардың мұрагері әр бетте белгілі бір элементтерді сақтауға мүмкіндік береді (мысалы, үстіңгі деректеме, Навигация және төменгі деректеме).

Автоматты экрандау қосулы, сондықтан ``name`` HTML болса, ол автоматты түрде қорғалады. Егер сіз айнымалыға сене алсаңыз және оның қауіпсіз HTML болатынын білсеңіз (мысалы, ол Уики белгілеуді HTML-ге түрлендіретін модульден алынғандықтан), оны қауіпсіз деп белгілеуге болады :class:`~markupsafe.Markup`  немесе ``|safe``  сүзгісін қолдану арқылы белгілеу класы. Қосымша мысалдар алу үшін Jinja2 құжаттамасын қараңыз.

Міне, қалай жұмыс істейтіні туралы қысқаша кіріспе :class:`~markupsafe.Markup`.Белгілеу класы жұмыс істейді::

    >>> from markupsafe import Markup
    >>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'
    Markup('<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')
    >>> Markup.escape('<blink>hacker</blink>')
    Markup('&lt;blink&gt;hacker&lt;/blink&gt;')
    >>> Markup('<em>Marked up</em> &raquo; HTML').striptags()
    'Marked up » HTML'

.. versionchanged:: 0.5

   Autoescaping is no longer enabled for all templates.  The following
   extensions for templates trigger autoescaping: ``.html``, ``.htm``,
   ``.xml``, ``.xhtml``.  Templates loaded from a string will have
   autoescaping disabled.

.. [#] Бұл нысанның не екенін білмейсіз  :class:`~flask.g`? Бұл ақпаратты өз қажеттіліктеріңіз үшін сақтауға болатын нәрсе. Құжаттаманы қараңыз: сынып:class:`flask.g` and :doc:`patterns/sqlite3`.


Сұрау деректеріне қол жеткізу
----------------------

Веб-қосымшалар үшін клиент серверге жіберетін деректерге жауап беру өте маңызды. Flask - те бұл ақпаратты global :class:`~flask.request` нысанмен ұсынылған . Егер сізде Python тәжірибесі болса, Сіз бұл нысанның қалай жаһандық болуы және Flask қалай қауіпсіз қала алады деген сұрақтар туындауы мүмкін. Жауап жергілікті тұрғындардың контекстінде:


.. _context-locals:

Context Locals
``````````````

.. admonition:: Insider Information

  Егер сіз оның қалай жұмыс істейтінін және жергілікті контексттермен тестілерді қалай жүзеге асыруға болатындығын түсінгіңіз келсе, осы бөлімді оқып шығыңыз, әйтпесе оны өткізіп жіберіңіз.

Flask-Тегі кейбір нысандар жаһандық нысандар болып табылады, бірақ әдеттегі түрі емес. Бұл нысандар іс жүзінде белгілі бір контекст үшін жергілікті объектілерге арналған прокси-серверлер болып табылады.  Қандай толық ауыз.  Бірақ оны түсіну өте оңай.

Контекст өңдеу ағыны деп елестетіп көріңіз. Сұраныс келіп веб-сервер Жаңа ағын құруды шешеді (немесе басқа нәрсе, негізгі объект ағындардан басқа параллелизм жүйелерімен жұмыс істей алады). Flash ішкі сұраныстарды өңдеуді іске қосқанда, ол ағымдағы ағынның белсенді контекст екенін анықтайды және ағымдағы қолданба мен wsgi орталарын осы контекстке (ағынға) байланыстырады. Ол бұл түрде жасайды, сол бір қолданба басқа қолданбаны ақаусыз шақыра алады.

Сонымен, бұл сіз үшін нені білдіреді? Негізінде, егер сіз модульдік тестілеу сияқты нәрсені жасамасаңыз, бұл жағдайды мүлдем елемеуге болады. Сұрау нысанына тәуелді код кенеттен үзілетінін екенін байқа-аласыз , себебі сұрау нысаны жоқ. Шешім: сұрау нысанын өздігінен құру және оны контекстке байланыстыру. Модульдік тестілеудің ең оңай шешімі :meth:`~flask.Flask.test_request_context` . ``with`` операторымен бірге ол сынақ сұрауын байланыстырады, осылайша сіз онымен әрекеттесе аласыз. Міне мысал:: 

    from flask import request

    with app.test_request_context('/hello', method='POST'):
        # now you can do something with the request until the
        # end of the with block, such as basic assertions:
        assert request.path == '/hello'
        assert request.method == 'POST'

Тағы бір мүмкіндік бүкіл wsgi ортасын беру
:meth:`~flask.Flask.request_context` method::

    with app.request_context(environ):
        assert request.method == 'POST'

Сұрау нысаны
``````````````````

Сұрау нысаны API бөлімінде құжатталған және біз оны мұнда егжей-тегжейлі қарастырмаймыз (:class:`~flask.Request`). Міне, кейбір кең таралған операцияларға жалпы шолу. Ең алдымен, оны ``flask`` модулінен импорттау керек::

    from flask import request

Ағымдағы сұрау әдісі :attr:`~flask.Request.method`. Пішін деректеріне қол жеткізу үшін 
(``POST``немесе ``PUT``сұрауында берілген деректер)  :attr:`~flask.Request.form` атрибутты пайдалануға болады . Жоғарыда аталған екі атрибуттың толық мысалы::

    @app.route('/login', methods=['POST', 'GET'])
    def login():
        error = None
        if request.method == 'POST':
            if valid_login(request.form['username'],
                           request.form['password']):
                return log_the_user_in(request.form['username'])
            else:
                error = 'Invalid username/password'
        # the code below is executed if the request method
        # was GET or the credentials were invalid
        return render_template('login.html', error=error)

Егер кілт ``form`` атрибутында болмаса не болады? Бұл жағдайда арнайы :exc:`KeyError`пайда болады. Сіз оны стандартты ретінде ұстай аласыз :exc:`KeyError`, бірақ олай етпесеңіз, оның орнына қате HTTP 400 сұрауының қате беті көрсетіледі. Осылайша, көптеген жағдайларда сіз бұл мәселеге тап болмайсыз.

URL (``?key=value``)  мекенжайында көрсетілген параметрлерге қол жеткізу үшін, сіз :attr:`~flask.Request.args` attribute:: пайдалана аласыз

    searchword = request.args.get('key', '')

Біз URL параметрлеріне `get`  арқылы немесе  :exc:`KeyError` арқылы ұстап алып қол жеткізуді ұсынамыз , өйткені пайдаланушылар URL мекенжайын өзгерте алады, бұл жағдайда оларға 400 қате сұрауы бар бетті ұсыну пайдаланушыға ыңғайлы болмайды.

Request объектісінің әдістері мен атрибуттарының толық тізімін алу үшін  :class:`~flask.Request` құжаттамаға өтіңіз  .


Download files
````````````

Жүктелген файлдарды Flask көмегімен оңай өңдеуге болады. HTML формасында  ``enctype="multipart/form-data"`` атрибутын орнатуды ұмытпаңыз, әйтпесе браузер сіздің файлдарыңызды мүлдем жібермейді.

Жүктелген файлдар жадта немесе файлдық жүйенің уақытша орналасуында сақталады. Бұл файлдарға :attr:`~flask.request.files` жерден қарап, сұрау обьектердін атрибутқа кіруге болады . Жүктелген әрбір файл осы сөздікте сақталады.  Ол стандартты Python :class:`file` нысаны сияқты әрекет етеді, бірақ сонымен бірге :meth:`~werkzeug.datastructures.FileStorage.save`.Бұл файлды сервер файлдық жүйесінде сақтауға мүмкіндік беретін әдіс. Міне, оның қалай жұмыс істейтінін көрсететін қарапайым мысал::

    from flask import request

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            f = request.files['the_file']
            f.save('/var/www/uploads/uploaded_file.txt')
        ...

Егер сіз файл сіздің қосымшаңызға жүктелмес бұрын клиентте қалай аталғанын білгіңіз келсе, оған қол жеткізе аласыз :attr:`~werkzeug.datastructures.FileStorage.filename`  атрибуты. Дегенмен, бұл мән жалған болуы мүмкін екенін есте сақтаңыз, сондықтан бұл мәнге ешқашан сенбеңіз. Файлды серверде сақтау үшін клиент файлының атын пайдаланғыңыз келсе, оны :func:`~werkzeug.utils.secure_filename` функция арқылы жіберіңіз ::

    from werkzeug.utils import secure_filename

    @app.route('/upload', methods=['GET', 'POST'])
    def upload_file():
        if request.method == 'POST':
            file = request.files['the_file']
            file.save(f"/var/www/uploads/{secure_filename(file.filename)}")
        ...

Толығырақ мысалдар алу үшін қараңыз: :doc:`patterns/fileuploads`.

Кукилар
```````

Cookie файлдарына қол жеткізу үшін :attr:`~flask.Response.set_cookie` атрибутын қолданыз. Cookies орнату үшін :attr:`~flask.Response.set_cookie`жауап обьектердін әдістерін қолдануға болады. Клиент жіберетін барлық cookie файлдармен сөздік жауап обьектердін :attr:`~flask.Request.cookies` атрибут. Егер сіз сеанстарды пайдаланғыңыз келсе, cookie файлдарын тікелей пайдаланбаңыз, оның орнына Flask ішіндегі :ref:`sessions` пайдаланыңыз, бұл сізге cookie файлдарының үстіне қауіпсіздік қосады.

Кукиларды оқу::

    from flask import request

    @app.route('/')
    def index():
        username = request.cookies.get('username')
        # use cookies.get(key) instead of cookies[key] to not get a
        # KeyError if the cookie is missing.

Кукиларды сақтау::

    from flask import make_response

    @app.route('/')
    def index():
        resp = make_response(render_template(...))
        resp.set_cookie('username', 'the username')
        return resp

Куки файлдары жауап нысандарға орнатылғанын ескеріңіз. Сіз әдетте шолу функцияларынан жолдарды қайтаратындықтан, Flask оларды сіз үшін жауап нысандарына түрлендіреді. Егер сіз мұны нақты жасағыңыз келсе, Сіз :meth:`~flask.make_response` , тек содан кейін оны өзгерте аласыз.

Кейде сізге cookie файлын жауап нысаны әлі жоқ жерде орнату қажет болуы мүмкін. Бұл :doc:`patterns/deferredcallbacks` арқылы мүмкін болады .

Бұл туралы  :ref:`about-responses` да қараңыз.

Қайта бағыттау және қателер
--------------------

Пайдаланушыны басқа соңғы нүктеге бағыттау үшін :func:`~flask.redirect` функциясын қолдаңыз; қате кодымен сұрауды мерзімінен бұрын тоқтату үшін :func:`~flask.abort` функциясын қолданыңыз::

    from flask import abort, redirect, url_for

    @app.route('/')
    def index():
        return redirect(url_for('login'))

    @app.route('/login')
    def login():
        abort(401)
        this_is_never_executed()

Бұл өте мағынасыз мысал, өйткені пайдаланушы индекстен кіре алмайтын бетке бағытталады (401 кіруге тыйым салынғанын білдіреді), бірақ ол оның қалай жұмыс істейтінін көрсетеді.

Әдепкі бойынша, әрбір қате коды үшін ақ-қара қате беті көрсетіледі. Қате бетін реттегіңіз келсе :meth:`~flask.Flask.errorhandler`  декораторды пайдалана аласыз::

    from flask import render_template

    @app.errorhandler(404)
    def page_not_found(error):
        return render_template('page_not_found.html'), 404

:func:`~flask.render_template` қоңырау шалғаннан кейін ``404``- ке назар аударыңыз. Бұл flask-ке бұл беттің статусы коды 404 болуы керек, бұл "табылмады" дегенді білдіреді. Әдепкі бойынша, 200 мәні келесідей аударылады: бәрі жақсы өтті.

Қосымша ақпарат алу үшін :doc:`error handling` қараңыз.

.. _about-responses:

Жауаптар туралы
---------------

Көру функциясынан қайтарылған мән сіз үшін автоматты түрде жауап нысанына түрлендіріледі. Егер қайтару мәні жол болса, ол жауап беру объектісіне жауап денесі ретінде жол, ````200 OK`` кодтың статусы және mime-type :mime type:`text/html`  түрінде түрлендіріледі. Егер қайтару мәні dict немесе list болса, жауап алу үшін :func:`jsonify`деп аталады. Flask қайтарылған мәндерді жауап нысандарына түрлендіру үшін қолданатын Логика келесідей:

1. Егер жауап нысаны дұрыс түрге қайтарылса, ол тікелей көріністен қайтарылады.
2. Егер бұл жол болса, response нысаны осы деректермен және әдепкі параметрлермен жасалады.
3. Егер бұл жолдарды немесе байттарды қайтаратын итератор немесе генератор болса, ол ағындық жауап ретінде өңделеді.
4. Егер бұл сөздік немесе тізім болса, жауап нысаны :func:`~flask.json.jsonify`.
5. Егер кортеж қайтарылса, кортеждегі элементтер қосымша ақпарат бере алады. Мұндай кортеждер ``(response, status)``,``(response, headers)`` немесе``(response, status, headers)`` түрінде болуы керек. ``status`` мәні күй кодын жоққа шығарады, ал ``headers`` қосымша тақырып мәндерінің тізімі немесе сөздігі болуы мүмкін.
6. Егер бұлардың ешқайсысы жұмыс істемесе, Flask қайтару мәні жарамды WSGI қолданбасы деп есептейді және оны жауап нысанына түрлендіреді.

Егер сіз көрініс ішіндегі алынған жауап нысанына қол жеткізгіңіз келсе, келесі функцияны қолдана аласыз :func:`~flask.make_response`.

Сізде осындай көрініс бар деп елестетіп көріңіз::

    from flask import render_template

    @app.errorhandler(404)
    def not_found(error):
        return render_template('error.html'), 404

Қайтарылған өрнекті :func:`~flask.make_response` және оны өзгерту үшін response нысанын алыңыз, содан кейін оны қайтарыңыз::

    from flask import make_response

    @app.errorhandler(404)
    def not_found(error):
        resp = make_response(render_template('error.html'), 404)
        resp.headers['X-Something'] = 'A value'
        return resp


API-лер мен JSON
``````````````

API жазу кезінде жалпы жауап форматы-JSON. Flask көмегімен осындай API жазуды бастау оңай. Егер сіз көріністен ``dict``немесе ``list``қайтарсаңыз, олар JSON-ға жауап ретінде түрлендіріледі.

.. code-block:: python

    @app.route("/me")
    def me_api():
        user = get_current_user()
        return {
            "username": user.username,
            "theme": user.theme,
            "image": url_for("user_image", filename=user.image),
        }

    @app.route("/users")
    def users_api():
        users = get_all_users()
        return [user.to_json() for user in users]

Бұл кез келген қолдау көрсетілетін JSON деректер түрін сериялайтын  :func:`~flask.json.jsonify` функциясына деректерді жіберуге арналған төте жол. Бұл сөздік немесе тізімдегі барлық деректер JSON форматында сериялануы керек дегенді білдіреді.

Мәліметтер базасының модельдері сияқты күрделі типтер үшін алдымен деректерді жарамды JSON түрлеріне түрлендіру үшін сериялау кітапханасын пайдалану қажет болады. Қауымдастық күрделі қосымшаларды қолдайтын көптеген сериялау кітапханалары мен flask API кеңейтімдерін қолдайды.


.. _sessions:

Сессиялар
--------

Сұрау нысанынан басқа, пайдаланушыға қатысты ақпаратты бір сұраудан екіншісіне сақтауға мүмкіндік беретін :class:`~flask.session`  деп аталатын екінші нысан да бар. Бұл сіз үшін cookie файлдарының үстінде жүзеге асырылады және cookie файлдарына криптографиялық түрде қол қояды. Бұл дегеніміз, пайдаланушы сіздің cookie файлыңыздың мазмұнын көре алады, бірақ қол қою үшін пайдаланылатын құпия кілтті білмесе, оны өзгертпейді.

Сеанстарды пайдалану үшін құпия кілтті орнату керек.  Сеанстар осылай жұмыс істейді::

    from flask import session

    # Set the secret key to some random bytes. Keep this really secret!
    app.secret_key = b'_5#y2L"F4Q8z\n\xec]/'

    @app.route('/')
    def index():
        if 'username' in session:
            return f'Logged in as {session["username"]}'
        return 'You are not logged in'

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            session['username'] = request.form['username']
            return redirect(url_for('index'))
        return '''
            <form method="post">
                <p><input type=text name=username>
                <p><input type=submit value=Login>
            </form>
        '''

    @app.route('/logout')
    def logout():
        # remove the username from the session if it's there
        session.pop('username', None)
        return redirect(url_for('index'))

.. admonition::Жақсы құпия кілттерді қалай жасауға болады

Құпия кілт мүмкіндігінше кездейсоқ болуы керек. Сіздің амалдық жүйеңізде кездейсоқ сандардың криптографиялық генераторына негізделген кездейсоқ деректерді жасаудың тәсілдері бар. 
  :attr:`Flask.secret_key` (or :data:`SECRET_KEY`)
мәнін жылдам жасау үшін келесі пәрменді пайдаланыңыз::

        $ python -c 'import secrets; print(secrets.token_hex())'
        '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'

Cookie файлдарына негізделген сеанстар туралы ескерту: Flask сессия нысанына енгізген мәндерді қабылдайды және оларды cookie файлына сериялайды.  Егер сіз кейбір мәндер сұрауларда сақталмайтынын байқасаңыз, cookie файлдары шынымен қосылады және сіз нақты қате туралы хабарлама алмасаңыз, веб-шолғыштар қолдайтын өлшеммен салыстырғанда парағыңыздың жауаптарындағы cookie файлының өлшемін тексеріңіз.

Әдепкі клиент жағындағы сеанстардан басқа, оның орнына сервер жағындағы сеанстарды өңдегіңіз келсе, оны қолдайтын бірнеше Flask кеңейтімдері бар.

Жыпылықтайтын хабарлама
----------------

Жақсы қолданбалар мен пайдаланушы интерфейстері кері байланысқа байланысты. Егер пайдаланушы жеткілікті кері байланыс алмаса, олар қолданбаны жек көруі мүмкін. Flask жыпылықтау жүйесі арқылы пайдаланушыға кері байланыс берудің өте қарапайым әдісін ұсынады. Жыпылықтау жүйесі негізінен сұраудың соңында хабарламаны жазуға және келесі сұрауда (және тек келесі сұрауда) оған қол жеткізуге мүмкіндік береді. Бұл әдетте хабарламаны көрсету үшін орналасу үлгісімен біріктіріледі.

Хабарлама жіберу үшін келесі әдісті қолданыңыз  :func:`~flask.flash` хабарламаларға қол жеткізу үшін Сіз шаблондарда қол жетімді  :func:`~flask.get_flashed_messages`қолдана аласыз. Қараңыз: doc: `үлгілер/жыпылықтау` толық мысал үшін.

Тіркеу
-------

.. versionadded:: 0.3

Кейде Сіз дұрыс болуы керек деректермен айналысатын жағдайға тап болуыңыз мүмкін, бірақ олай емес. Мысалы, сізде серверге HTTP сұрауын жіберетін клиенттік код болуы мүмкін, бірақ ол дұрыс қалыптаспаған сияқты. Бұл Пайдаланушының деректерге араласуынан немесе клиенттік кодтың бұзылуынан туындауы мүмкін. Көп жағдайда мұндай жағдайда ``400 Bad Request``жауап беруге болады, бірақ кейде олай болмайды және код жұмыс істей беруі керек.

Сіз әлі де күдікті нәрсе болғанын тіркегіңіз келуі мүмкін.  Мұнда ағаш кесушілер пайдалы болады.  Flask 0.3 нұсқасынан бастап Тіркеуші сіздің пайдалануыңыз үшін алдын ала конфигурацияланған.

Журнал қоңырауларының кейбір мысалдары::

    app.logger.debug('A value for debugging')
    app.logger.warning('A warning occurred (%d apples)', 42)
    app.logger.error('An error occurred')

Қосымша :attr:`~flask.Flask.logger`- стандартты журнал :class:`~logging.Logger`, сондықтан қосымша ақпарат алу үшін ресми құжаттарға жүгініңіз :mod:`logging`.

:doc:`errorhandling` Қараңыз.


WSGI аралық бағдарламалық жасақтамасына қосылу
--------------------------

Flask қолданбасына WSGI аралық бағдарламалық құралын қосу үшін ``wsgi_app`` қолданбасының атрибутын ораңыз. Мысалы, Nginx жұмыс істеу үшін Werkzeugs
 ::class:`~werkzeug.middleware.proxy_fix. Proxy Fix` аралық бағдарламалық жасақтамасын қолдану:

.. code-block:: python

    from werkzeug.middleware.proxy_fix import ProxyFix
    app.wsgi_app = ProxyFix(app.wsgi_app)

``app`` орау орнына  ``app.wsgi_app``,  ' app ' әлі де Flask қосымшасын көрсетедідегенді білдіреді, аралық бағдарламалық жасақтама емес. Сондықтан сіз `app` бағдарламасын тікелей қолдана және теңшей аласыз.

Flask қосымшаларды орнату
----------------------

Қосымшалар - бұл жалпы тапсырмаларды орындауға көмектесетін пакеттер. Мысалы, Flask-SQLAlchemy - SQLAlchemy қолдауын ұсынады, бұл оны Flask көмегімен пайдалануды жеңілдетеді.

Flask қосамшаларды туралы көбірек ақпаратты мына жерден қараңыз  :doc:`extensions`.

Веб-серверде орналастыру
-------------------------

Жаңа flask қолданбасын орналастыруға дайынсыз ба? :doc:`deploying/index` қараңыз.
